<!DOCTYPE HTML>
<html>

<head>
    <title>this is a test</title>
    <meta charset="UTF-8">
    <script src="jquery-1.11.3.js"></script>
    <script src="Bignum.js"></script>
    <script src="Mset.js"></script>
    <script src="ImageBit.js"></script>

    <link rel="stylesheet" type="text/css" href="MsetStyles.css"/>
    
    <script>
        // global variables
        var precision = 20;

        var canvas1;
        var canvas2;
        var mouseWindowHeight, mouseWindowWidth;
        var oldX, oldY;
        var op;
        var ctx1, ctx2;
        var mousePosx, mousePosy;
        var imgDt;
        var worker = new Array();
        var refSet = new MSet();
      
        function relMouseCoords(e) {

            var totalOffsetX = 0;
            var totalOffsetY = 0;
            var canvasX = 0;
            var canvasY = 0;
            var currentElement = this;


            do {
                totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
                totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
            }
            while (currentElement = currentElement.offsetParent)

            canvasX = event.pageX - totalOffsetX;
            canvasY = event.pageY - totalOffsetY;

            return { x: canvasX, y: canvasY }

        }

        HTMLCanvasElement.prototype.relativeMouseCoords = relMouseCoords;


        function init() {

            canvas1 = document.getElementById("canvas1");
            ctx1 = canvas1.getContext("2d");
            canvas2 = document.getElementById("canvas2");
            ctx2 = canvas2.getContext("2d");

            canvas1.width = $("#canvasContainer").width();
            canvas1.height = $("#canvasContainer").height();
            canvas2.width = $("#canvasContainer").width();
            canvas2.height = $("#canvasContainer").height();

            mouseWindowWidth = canvas1.width / 5 + 1;
            mouseWindowHeight = canvas1.height / 5 + 1;

            $("#out1").val(-2.5) ;  // start with -2.5
            $("#out2").val(1.5);  // start with 1.2
            $("#out3").val(1);    // start with 1

            $("#out1").val("-0.54312581739875619841");
            $("#out2").val("0.6164775950855575808");
            $("#out3").val("-0.54312581739874339840");

            $("#out1").val("-0.54312581739874901808116477248");
            $("#out2").val("0.61647759508555502524462107392");
            $("#out3").val("-0.54312581739874901804839674688");

            $("#iterationMultiplier").val(1);
            $("#threshMult").val(1);


            var maxMult = $("#iterationMultiplier").val();
            var x1 = new Big($("#out1").val());
            var y1 = new Big($("#out2").val());
            var x2 = new Big($("#out3").val());
            var maxiter = Math.floor(maxMult * Math.max(100, Math.abs(30 * Math.log(x2.minus(x1).toFloat()))));  // this is an empirical approximation. Nothing mathematical. Just grows slowly
            refSet.maxiter = maxiter;
            $('#out5').val(maxiter);

            var threshMult = parseFloat($("#threshMult").val());
            var threshold = Math.floor(10 + Math.abs(x2.minus(x1).e)) * threshMult;
            refSet.threshold = threshold;
            $('#out6').val(threshold);

            refSet.setRefPoint(null);
            refSet.xyInc = x2.minus(x1).toFloat() / canvas1.width;
            refSet.setRefDistance();

            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);

            imgDt = ctx1.createImageData(canvas1.width, canvas1.height);
            paintThreadSet(imgDt);


            /*******************************************************
            /* Clear the sprite when the mouse leaves the canvas
            /*******************************************************/

            canvas2.onmouseleave = function (e) {
                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            }


            /*******************************************************
            /* Redraws the sprite when the mouse moves
            /*******************************************************/

            canvas2.onmousemove = function (e) {

                var relativeCoords = canvas2.relativeMouseCoords(e);
                ctx2.clearRect(oldX - mouseWindowWidth / 2 - 3, oldY - mouseWindowHeight / 2 - 3, mouseWindowWidth + 6, mouseWindowHeight + 6);

                ctx2.fillStyle = "rgba(100, 100, 100, 0.3)";
                ctx2.fillRect(relativeCoords.x - mouseWindowWidth / 2, relativeCoords.y - mouseWindowHeight / 2, mouseWindowWidth, mouseWindowHeight);

                oldX = relativeCoords.x; oldY = relativeCoords.y;

            };

            /*******************************************************
            /* Resizes when the mouse wheel scrolls
            /*******************************************************/

            canvas2.onmousewheel = function (e) {

                // determine whether we are zooming in or out.

                var relativeCoords = canvas2.relativeMouseCoords(e);
                var delta = Math.max(-1, Math.min(1, e.wheelDelta));
                if (delta == 1) zoom = new Big(0.7);
                else zoom = new Big(1.7);

                // stores the old coordinates

                var currX1 = new Big($("#out1").val());
                var currY1 = new Big($("#out2").val());
                var currX2 = new Big($("#out3").val());
                var currxSpan = currX2.minus(currX1);
                var currySpan = currxSpan.times(canvas2.height).divint(canvas2.width);

                if (currxSpan.toFloat() > 3 && delta == -1) zoom = 1; //dont zoom way out of the image
                if (delta == -1) $("#iterationMultiplier").val(1); // dont compute when zooming out
                // Calculate the new coordinates

                var newxSpan = currxSpan.times(zoom); //first calculate the dimensions of the new window
                var newySpan = currySpan.times(zoom);

                var xPerc = 1 - ( canvas2.width - relativeCoords.x ) / canvas2.width; // the % of mouse from left
                var yPerc = 1 - ( canvas2.height - relativeCoords.y) / canvas2.offsetHeight; // the % of mouse from top

                var currX = currX1.plus(currxSpan.times(relativeCoords.x).divint(canvas2.width));
                var currY = currY1.minus(currySpan.times(relativeCoords.y).divint(canvas2.height));


                var x1 = currX.minus(newxSpan.times(new Big(xPerc)));
                var x2 = x1.plus(newxSpan);
                var y1 = currY.plus( newySpan.times(new Big(yPerc)));


                ctx1.clearRect(0, 0, canvas1.width, canvas1.height);

                $("#out1").val(x1.toString());
                $("#out2").val(y1.toString());
                $("#out3").val(x2.toString());

                paintThreadSet();


            }

            //*******************************************************
            //* Simply stores the position of the mouse on click to check for drag on mouseup
            //*******************************************************
            canvas2.onmousedown = function (e) {

                relativeCoords = canvas2.relativeMouseCoords(e);
                mousePosx = relativeCoords.x;
                mousePosy = relativeCoords.y;
            }

            //*******************************************************
            //* triggers a redraw depending on drag or click.
            //*******************************************************

            canvas2.onmouseup = function (e) {

                var imgDt;
                var relativeCoords = canvas2.relativeMouseCoords(e);
                var currX1 = new Big($("#out1").val());
                var currY1 = new Big($("#out2").val());
                var currX2 = new Big($("#out3").val());
                
                var threshMult = parseFloat($("#threshMult").val());
                var maxMult = parseFloat($("#iterationMultiplier").val());

                var xSpan = currX2.minus(currX1);
                var ySpan = xSpan.times(canvas2.height).divint(canvas2.width);


                if (relativeCoords.x != mousePosx || relativeCoords.y != mousePosy) {
                    var x1 = currX1.minus(xSpan.times(relativeCoords.x - mousePosx).divint(canvas2.width));
                    var y1 = currY1.plus(ySpan.times(relativeCoords.y - mousePosy).divint(canvas2.height));
                    var x2 = x1.plus(xSpan);
                    // we have drag so take a snapshot of the image and shift it so dont clear it all.
                    imgDt = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);
                    ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
                    ctx1.putImageData(imgDt, relativeCoords.x - mousePosx, relativeCoords.y - mousePosy);
                    
                }

                else { // this is a click Zoom

                    var sp = xSpan.times(parseInt(relativeCoords.x - mouseWindowWidth / 2)).divint(canvas2.width);
                    var spx = xSpan.divint(5);
                    var x1 = currX1.plus(sp);
                    var x2 = x1.plus(spx);
                    var y1 = currY1.minus(ySpan.times(parseInt(relativeCoords.y - mouseWindowHeight / 2)).divint(canvas2.height));
                   
                    //var f = x2.minus(x1).toFloat();
                    var maxiter = Math.floor(maxMult * Math.max(100, Math.abs(30 * Math.log(x2.minus(x1).toFloat()))));  // this is an empirical approximation. Nothing mathematical. Just grows slowly
                    refSet.maxiter = maxiter;
                    $('#out5').val(maxiter);

                    //var threshMult = parseFloat($("#threshMult").val());
                    var threshold = Math.floor(10 + Math.abs(x2.minus(x1).e)) * threshMult;
                    refSet.threshold = threshold;
                    $('#out6').val(threshold);

                    var canvasData = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);
                    var imgBit = new ImageBit(canvasData, currX1, currY1, currX2);
                    refSet.setRefPoint(imgBit);
                    refSet.setRefDistance();
                
                    ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
                    


                }

                $("#out1").val(x1.toString());
                $("#out2").val(y1.toString());
                $("#out3").val(x2.toString());

                paintThreadSet();


            } //onmouseup



        }   // init


        //*******************************************************
        // Re-runs the same picture allowing user to modify some settings
        //******************************************************
        recalculate = function () {
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);

            var maxMult = $("#iterationMultiplier").val();
            var x1 = new Big($("#out1").val());
            var y1 = new Big($("#out2").val());
            var x2 = new Big($("#out3").val());
            var maxiter = Math.floor(maxMult * Math.max(100, Math.abs(30 * Math.log(x2.minus(x1).toFloat()))));  // this is an empirical approximation. Nothing mathematical. Just grows slowly
            refSet.maxiter = maxiter;
            $('#out5').val(maxiter);

            var threshMult = parseFloat($("#threshMult").val());
            var threshold = Math.floor(10 + Math.abs(x2.minus(x1).e)) * threshMult;
            refSet.threshold = threshold;
            $('#out6').val(threshold);


            paintThreadSet();
        }


        //*******************************************************
        // Presets
        //******************************************************
        reset = function () {
            $("#out1").val(-2.5);
            $("#out2").val(1);
            $("#out3").val(1);
            $("#iterationMultiplier").val(1);
            $("#threshMult").val(1);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

        preset1 = function () {
            $("#out1").val(-0.1691381123916208);
            $("#out2").val(0.6505404350243774);
            $("#out3").val(-0.16913809694267987);
            $("#iterationMultiplier").val(4);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

        preset2 = function () {
            $("#out1").val(-0.5431258187760334);
            $("#out2").val(0.6164775955475615);
            $("#out3").val(-0.5431258187760332);
            $("#iterationMultiplier").val(0.3);
            $("#threshMult").val(1);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }
        preset3 = function () {
            $("#out1").val(-0.7272521592648912);
            $("#out2").val(0.24029350384390788);
            $("#out3").val(-0.7272521590179414);
            $("#iterationMultiplier").val(2);
            $("#threshMult").val(10);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

   
        //*******************************************************
        // Presets
        //******************************************************

        thicker = function () {
            $("#threshMult").val(0.12);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

        normal = function () {
            $("#threshMult").val(1);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

        thiner = function () {
            $("#threshMult").val(10);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

        details = function () {
            $("#iterationMultiplier").val(3);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }

        faster = function () {
            $("#iterationMultiplier").val(1);
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            paintThreadSet();
        }



        /*******************************************************
        /* Triggers the computation and drawing of the Set
        /*******************************************************/

        function paintThreadSet() {


            var x1 = new Big($("#out1").val());
            var y1 = new Big($("#out2").val());
            var x2 = new Big($("#out3").val());
            var col1 = $("#color1").val();
            var col2 = $("#color2").val();
            var col3 = $("#color3").val();
            var threshold = $("#out6").val();
            var maxiter = $("#out5").val();

            refSet.setColor(col1, col2, col3);

            //var maxMult = parseFloat($("#iterationMultiplier").val());
            //var maxiter = Math.floor(maxMult * Math.max(100, Math.abs(30 * Math.log(x2.minus(x1).toFloat()))));  // this is an empirical approximation. Nothing mathematical. Just grows slowly
            //$('#out5').val(maxiter);

            //var threshMult = parseFloat($("#threshMult").val());
            //var threshold = Math.floor(10 + Math.abs(x2.minus(x1).e)) * threshMult;
            //$('#out6').val(threshold);



             
            //var canvasData = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);
            //var imgBit = new ImageBit(canvasData, x1, y1, x2);
            //refSet.setColor(col1, col2, col3);
            //refSet.maxiter = maxiter;
            //refSet.threshold = threshold;


            //refSet.xRef = new Big("-0.543125818776033354");
            //refSet.yRef = new Big("0.6164775955475614916");
            //refSet.setRefPoint(imgBit);
            
            //refSet.xyInc = f / canvas1.width; // this is normally calculated as part of the paint function, but here we pass it because we dont paint the ref point. 
            //refSet.setRefDistance();

            
            var numworkers = 1;

            var xpixel = 0, ypixel = 0;  // keeps count of the index of the subimage

            var workerCount = 0;
            var totalWorkers = numworkers * numworkers;
            
            for (var i = 0; i < numworkers; i++) {

                var subwidth = Math.floor(canvas1.width / numworkers);
                if (i == numworkers - 1) //if we have reached the last image, take all remaining pixels regardless of rounding
                    subwidth = canvas1.width - i * subwidth;

                for (var j = 0; j < numworkers; j++) {

                    var subheight = Math.floor(canvas1.height / numworkers);
                    if (j == numworkers-1) //if we have reached the last image, take all remaining pixels regardless of rounding
                        subheight = canvas1.height - j * subheight;

                    // take a snapshot of the subimage.
                    var imgData = ctx1.getImageData(xpixel, ypixel, subwidth, subheight);

                    var subx1 = x1.plus((x2.minus(x1)).times(new Big(xpixel/canvas1.width)));
                    var suby1 = y1.minus((x2.minus(x1)).times(new Big(ypixel/canvas1.width)));
                    var subx2 = x1.plus((x2.minus(x1)).times(new Big((xpixel + subwidth)/canvas1.width)));

                    //construct message to pass to the worker
                    var workerMessage = {
                        workerID: i*numworkers+j,
                        maxiter: maxiter,
                        threshold: threshold,
                        px1: xpixel, // the index of the subimage in the full image
                        py1: ypixel,
                        col1: col1, // the three colors
                        col2: col2,
                        col3: col3,
                        imgData: imgData,
                        subwidth: subwidth,
                        subheight: subheight,
                        precision: precision,

                        subx1: subx1,
                        subx2: subx2,
                        suby1: suby1,

                        refSet: refSet,
                    };

                    //create the worker.
                    var ind = numworkers * i + j;
                    if (worker[ind]) worker[ind].terminate();
                    worker[ind] = new Worker("MsetWorker.js");

                    //Start the worker by posting the data. This triggers the "onmessage" function in the worker file.
                    worker[ind].postMessage(workerMessage);

                    //registers the name of the callback function which the worker shoudl call when finished an which is defined later on the UI thread 
                    worker[ind].onmessage = workerCallback;

                    ypixel = ypixel + subheight;
                } // for j loop

                ypixel = 0; // reset the y position for each iteration of x
                xpixel = xpixel + subwidth; // keep tab of the current subimage position
            } // for i loop


            //defines the call back function, which determinse what should happen when the workers finish. In this case, paint the image.
            function workerCallback(e) {
                ctx1.putImageData(e.data.imgData, Math.floor(e.data.px1), Math.floor(e.data.py1));
                workerCount++;
            }

        } //paintThreadSet


    </script>

</head>


<body onload="init();">
    <div style="width: 200px;" >
    
        <div id="canvasContainer" style="position:relative; height:200px; " >
            <canvas id="canvas1" ></canvas>
            <canvas id="canvas2" ></canvas>
        </div>
        
        <div class="item_line">
            <button onclick="thicker()">> Lines</button>
            <button onclick="normal()">= Lines</button>
            <button onclick="thiner()">< Lines</button>
            <button onclick="details()">More Details</button>
            <button onclick="faster()">Normal Details</button>
             
            <label>Colors</label>
            <input id="color1" type="color" style="width:55px" value="#323264" > 
            <input id="color2" type="color" style="width:55px" value="#FF3264" >
            <input id="color3" type="color" style="width:55px" value="#00FF00" >
        
        </div>

        <div class="item_line">
            <button onclick="reset()">Reset</button>
            <button onclick="preset1()">Preset 1</button>
            <button onclick="preset2()">Preset 2</button>
        </div>

        <div class="item_line">
            <div>
            <label >MaxMult</label>
            <input id="iterationMultiplier" style="width:50px" value="1">
            <label >maxiter</label>
            <input id="out5" ; style="width:50px">
            <label >threshold</label>
            <input id="out6" onchange="recalculate()" style="width:50px" value="0">
            <label>threshold offset</label>
            <input id="threshMult" style="width:50px; " value="1" >
            <button onclick="recalculate()" >Recalculate</button>
            </div>  
            
            <div>  
                <label >X1</label>
                <input id="out1"; style="width:400px"  >
            </div>
            
            <div>
                <label>X2</label>
                <input id="out3" ; style="width:400px">
            </div>
            <div>
                <label>Y1</label>
                <input id="out2" ; style="width:400px">
            </div>



            </div>


       

    </div>
    
</body>
</html>
